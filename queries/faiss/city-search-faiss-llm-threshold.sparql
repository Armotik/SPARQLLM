## slm-run --config config.ini -f queries/city-search-faiss-llm-threshold.sparql --debug
## Objectif: calculer un threshold dynamique (par capitale) sur les scores FAISS
## puis n'appeler le LLM que si score >= threshold.
## NOTE: La fonction de recherche FAISS est exécutée deux fois (une pour stats, une pour résultats)
##       car SPARQL pur ne permet pas de réutiliser directement les bindings intermédiaires de la première
##       sous-requête comme une table temporaire avec graph side-effects.

PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX ex: <http://example.org/>

SELECT ?label ?chunk ?score ?threshold ?date ?name ?gf ?gl ?uri WHERE {
  # 1. Capitales européennes (limite de test ajustable)
  SERVICE <https://query.wikidata.org/sparql> {
    { SELECT * WHERE {
        ?country wdt:P31 wd:Q6256 ;
                 wdt:P30 wd:Q46 ;
                 wdt:P36 ?capital .
        ?capital rdfs:label ?label .
        FILTER(LANG(?label) = "en")
      } LIMIT 5 }
  }

  # 2. Texte de requête FAISS
  BIND(CONCAT("I want a cultural event related to cinema that is located in ", STR(?label)) AS ?rag)

  # 3. Sous-requête pour calculer un threshold dynamique par capitale
  #    Ici: threshold = (max(score) + avg(score)) / 2  (ex: compromis entre meilleur et moyenne)
  {
    SELECT ?capital ( (MAX(?sc) + AVG(?sc)) / 2 AS ?threshold ) WHERE {
      BIND(ex:SLM-SEARCH-FAISS(?rag, ?capital, 5) AS ?gstats)
      GRAPH ?gstats {
        ?capital ex:is_aligned_with ?bnS .
        ?bnS ex:has_score ?sc .
      }
    } GROUP BY ?capital
  }

  # 4. Récupération complète des candidats (2ème exécution FAISS)
  BIND(ex:SLM-SEARCH-FAISS(?rag, ?capital, 5) AS ?gf)
  GRAPH ?gf {
    ?capital ex:is_aligned_with ?bn .
    ?bn ex:has_chunk ?chunk ;
        ex:has_source ?uri ;
        ex:has_score ?score .
  }

  # 5. Appel conditionnel du LLM uniquement si score >= threshold
  OPTIONAL {
    FILTER(?score >= ?threshold)
    BIND(ex:SLM-READFILE(?uri) AS ?page)
    BIND(CONCAT("""
We consider a type Event with the following properties:
  <http://schema.org/StartDate> : The start date of the event
  <http://schema.org/name> : The name of the event.
Extract from the text below, the date of the event and the name of the event.
Generate only output JSON-LD instance of the Event type with
this format replacing the 0 with the date of the event, and 1 with the name of the event:
 "@context": "https://schema.org/",
 "@type": "Event",
 "http://schema.org/StartDate": "0",
 "http://schema.org/name": "1",
<page>""", STR(?page), "</page>") AS ?prompt)
    BIND(ex:SLM-LLMGRAPH_OLLA(?prompt, ?uri) AS ?gl)
    GRAPH ?gl {
      ?uri <http://example.org/has_schema_type> ?root .
      ?root a <http://schema.org/Event> ;
            <http://schema.org/StartDate> ?date ;
            <http://schema.org/name> ?name .
    }
  }
}
ORDER BY DESC(?score)
LIMIT 20

# Améliorations possibles:
#  - Utiliser second meilleur score comme threshold: ORDER BY DESC(?sc) OFFSET 1 LIMIT 1 dans une sous-requête.
#  - Global threshold (une seule agrégation) en retirant ?capital du GROUP BY.
#  - Ajustement adaptatif externe: script Python qui calcule un quantile et réinjecte via PARAM.