#!/usr/bin/env python3
"""Plot average durations per model for the three MCP calls (search, snapshot, LLM)
from a CSV generated by the cultural-events.sparql query.

Usage:
    python scripts/plot_cultural_web_timings.py --csv out/cultural-web.csv --output plots/

The produced figure is a stacked bar chart: one bar per model, with segments for the
mean durations (durSearch, durSnap, durLLM). Segment times (seconds) are annotated,
and the total time is displayed above each bar.
"""
from __future__ import annotations
import argparse
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt


def load_and_aggregate(csv_path: Path, model_col: str = "finalModel") -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    # fallback if finalModel is absent
    if model_col not in df.columns:
        model_col = "requestedModel"
    # ensure required columns
    for col in ["durSearch", "durSnap", "durLLM"]:
        if col not in df.columns:
            raise ValueError(f"Missing column in CSV: {col}")
    grouped = df.groupby(model_col).agg({
        "durSearch": "mean",
        "durSnap": "mean",
        "durLLM": "mean"
    }).reset_index().rename(columns={model_col: "model"})
    # sort by total descending for readability
    grouped["total"] = grouped[["durSearch", "durSnap", "durLLM"]].sum(axis=1)
    grouped = grouped.sort_values("total", ascending=False)
    return grouped


def plot_stacked(df: pd.DataFrame, output_dir: Path, output_name: str = "cultural_web_mcp_durations.png") -> Path:
    colors = {
        "durSearch": "#1f77b4",  # bleu
        "durSnap": "#ff7f0e",    # orange
        "durLLM": "#2ca02c"       # vert
    }
    plt.figure(figsize=(8, 5))
    bottom = None
    x = range(len(df))
    labels_order = ["durSearch", "durSnap", "durLLM"]

    for label in labels_order:
        vals = df[label].values
        plt.bar(df["model"], vals, bottom=bottom, label=label, color=colors[label])
        if bottom is None:
            curr_bottom = [0]*len(vals)
        else:
            curr_bottom = bottom
        # annotations segment
        for i, v in enumerate(vals):
            if v <= 0:  # skip segments nuls
                continue
            plt.text(i, curr_bottom[i] + v/2, f"{v:.2f}s", ha="center", va="center", fontsize=9, color="white")
        bottom = vals if bottom is None else bottom + vals

    # annotation total au-dessus
    for i, total in enumerate(df["total"].values):
        plt.text(i, total + 0.05, f"{total:.2f}s", ha="center", va="bottom", fontsize=9, fontweight="bold")

    plt.ylabel("Average duration (s)")
    plt.xlabel("Model")
    plt.title("Average durations per MCP call by model")
    plt.xticks(rotation=20, ha="right")
    plt.legend(title="Segment")
    plt.tight_layout()
    output_dir.mkdir(parents=True, exist_ok=True)
    out_path = output_dir / output_name
    plt.savefig(out_path, dpi=150)
    return out_path


def main():
    parser = argparse.ArgumentParser(description="Plot stacked bar of average MCP call durations per model.")
    parser.add_argument("--csv", required=True, help="Path to the cultural-web.csv file")
    parser.add_argument("--output", required=True, help="Directory to store the output image")
    parser.add_argument("--use-requested", action="store_true", help="Use requestedModel instead of finalModel for grouping")
    args = parser.parse_args()

    csv_path = Path(args.csv)
    if not csv_path.exists():
        raise SystemExit(f"CSV not found: {csv_path}")

    model_col = "requestedModel" if args.use_requested else "finalModel"
    df = load_and_aggregate(csv_path, model_col=model_col)

    out_dir = Path(args.output)
    out_path = plot_stacked(df, out_dir)
    print(f"Generated chart: {out_path}")
    print(df[['model','durSearch','durSnap','durLLM','total']])


if __name__ == "__main__":
    main()
